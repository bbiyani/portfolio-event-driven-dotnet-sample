trigger:
  branches:
    include:
      - main

pr:
  branches:
    include:
      - main

variables:
  buildConfiguration: Release
  apiImageRepository: pensions360-api
  workerImageRepository: pensions360-worker
  dockerfileApi: deploy/Dockerfile-api
  dockerfileWorker: deploy/Dockerfile-worker
  imageTagPrefix: sha-
  # Expected to be set in pipeline variables or variable groups
  # containerRegistryServiceConnection
  # containerRegistryLoginServer (e.g. myregistry.azurecr.io)
  # AZURE_SUBSCRIPTION_ID
  # AZURE_RESOURCE_GROUP
  # AZURE_CONTAINER_APP_API
  # AZURE_CONTAINER_APP_WORKER
  # KEY_VAULT_URI

stages:
  - stage: BuildTest
    displayName: Build and Test
    jobs:
      - job: BuildTest
        displayName: Build and Test
        pool:
          vmImage: ubuntu-latest
        steps:
          - checkout: self

          - task: UseDotNet@2
            displayName: Use .NET 8 SDK
            inputs:
              packageType: sdk
              version: 8.0.x

          - script: dotnet restore Pensions360.sln
            displayName: Restore

          - script: dotnet build Pensions360.sln --configuration $(buildConfiguration) --no-restore
            displayName: Build

          - script: dotnet test Pensions360.sln --configuration $(buildConfiguration) --no-build
            displayName: Test

  - stage: BuildPush
    displayName: Build and Push Images
    dependsOn: BuildTest
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - job: BuildImages
        displayName: Build and push images
        pool:
          vmImage: ubuntu-latest
        steps:
          - checkout: self

          - script: |
              shortSha=${BUILD_SOURCEVERSION:0:7}
              imageTag="$(imageTagPrefix)${shortSha}"
              echo "##vso[task.setvariable variable=imageTag;isOutput=true]${imageTag}"
            name: SetVars
            displayName: Set image tag

          - task: Docker@2
            displayName: Build and push API image
            inputs:
              command: buildAndPush
              containerRegistry: $(containerRegistryServiceConnection)
              repository: $(apiImageRepository)
              dockerfile: $(dockerfileApi)
              buildContext: .
              tags: |
                $(imageTag)

          - task: Docker@2
            displayName: Build and push worker image
            inputs:
              command: buildAndPush
              containerRegistry: $(containerRegistryServiceConnection)
              repository: $(workerImageRepository)
              dockerfile: $(dockerfileWorker)
              buildContext: .
              tags: |
                $(imageTag)

          - script: |
              apiImage="$(containerRegistryLoginServer)/$(apiImageRepository):$(imageTag)"
              workerImage="$(containerRegistryLoginServer)/$(workerImageRepository):$(imageTag)"
              cat <<JSON > build-metadata.json
              {
                "imageTag": "$(imageTag)",
                "apiImage": "${apiImage}",
                "workerImage": "${workerImage}",
                "commit": "$(Build.SourceVersion)",
                "buildId": "$(Build.BuildId)"
              }
              JSON
            displayName: Write build metadata

          - publish: build-metadata.json
            artifact: build-metadata
            displayName: Publish build metadata

  - stage: DeployStaging
    displayName: Deploy to Staging
    dependsOn: BuildPush
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    variables:
      imageTag: $[ stageDependencies.BuildPush.BuildImages.outputs['SetVars.imageTag'] ]
    jobs:
      - deployment: DeployStaging
        displayName: Deploy to staging
        environment: staging
        pool:
          vmImage: ubuntu-latest
        strategy:
          runOnce:
            deploy:
              steps:
                - download: current
                  artifact: build-metadata

                - script: |
                    apiImage="$(containerRegistryLoginServer)/$(apiImageRepository):$(imageTag)"
                    workerImage="$(containerRegistryLoginServer)/$(workerImageRepository):$(imageTag)"
                    cat <<JSON > deploy-staging-metadata.json
                    {
                      "environment": "staging",
                      "imageTag": "$(imageTag)",
                      "apiImage": "${apiImage}",
                      "workerImage": "${workerImage}",
                      "subscriptionId": "$(AZURE_SUBSCRIPTION_ID)",
                      "resourceGroup": "$(AZURE_RESOURCE_GROUP)",
                      "containerAppApi": "$(AZURE_CONTAINER_APP_API)",
                      "containerAppWorker": "$(AZURE_CONTAINER_APP_WORKER)",
                      "keyVaultUri": "$(KEY_VAULT_URI)",
                      "commit": "$(Build.SourceVersion)",
                      "buildId": "$(Build.BuildId)"
                    }
                    JSON
                  displayName: Write staging deployment metadata

                - publish: deploy-staging-metadata.json
                  artifact: deploy-staging-metadata
                  displayName: Publish staging deployment metadata

                - script: |
                    echo "Deploying ${apiImage} and ${workerImage} to staging."
                    echo "Using Key Vault: $(KEY_VAULT_URI)"
                    echo "Resource group: $(AZURE_RESOURCE_GROUP)"
                  env:
                    apiImage: $(containerRegistryLoginServer)/$(apiImageRepository):$(imageTag)
                    workerImage: $(containerRegistryLoginServer)/$(workerImageRepository):$(imageTag)
                  displayName: Deploy to staging

  - stage: DeployProduction
    displayName: Deploy to Production
    dependsOn: DeployStaging
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    variables:
      imageTag: $[ stageDependencies.BuildPush.BuildImages.outputs['SetVars.imageTag'] ]
    jobs:
      - deployment: DeployProduction
        displayName: Deploy to production
        environment: production
        pool:
          vmImage: ubuntu-latest
        strategy:
          runOnce:
            deploy:
              steps:
                - download: current
                  artifact: build-metadata

                - script: |
                    apiImage="$(containerRegistryLoginServer)/$(apiImageRepository):$(imageTag)"
                    workerImage="$(containerRegistryLoginServer)/$(workerImageRepository):$(imageTag)"
                    cat <<JSON > deploy-production-metadata.json
                    {
                      "environment": "production",
                      "imageTag": "$(imageTag)",
                      "apiImage": "${apiImage}",
                      "workerImage": "${workerImage}",
                      "subscriptionId": "$(AZURE_SUBSCRIPTION_ID)",
                      "resourceGroup": "$(AZURE_RESOURCE_GROUP)",
                      "containerAppApi": "$(AZURE_CONTAINER_APP_API)",
                      "containerAppWorker": "$(AZURE_CONTAINER_APP_WORKER)",
                      "keyVaultUri": "$(KEY_VAULT_URI)",
                      "commit": "$(Build.SourceVersion)",
                      "buildId": "$(Build.BuildId)"
                    }
                    JSON
                  displayName: Write production deployment metadata

                - publish: deploy-production-metadata.json
                  artifact: deploy-production-metadata
                  displayName: Publish production deployment metadata

                - script: |
                    echo "Deploying ${apiImage} and ${workerImage} to production."
                    echo "Using Key Vault: $(KEY_VAULT_URI)"
                    echo "Resource group: $(AZURE_RESOURCE_GROUP)"
                  env:
                    apiImage: $(containerRegistryLoginServer)/$(apiImageRepository):$(imageTag)
                    workerImage: $(containerRegistryLoginServer)/$(workerImageRepository):$(imageTag)
                  displayName: Deploy to production
